// ========================================
// CACHE MANAGER - Sistema Multinivel de Cache
// ========================================
// Soporta 50+ usuarios simult√°neos sin exceder l√≠mites de API
// Autor: Sistema OM
// Fecha: 2024-12-04
// ========================================

/**
 * Cache multinivel con fallback autom√°tico
 * @param {string} key - Identificador √∫nico del cache
 * @param {function} fetchFunction - Funci√≥n para obtener datos si no est√° en cache
 * @param {number} ttlSeconds - Tiempo de vida en segundos (default: 1 hora)
 * @returns {*} Datos cacheados o frescos
 */
function getCached(key, fetchFunction, ttlSeconds = 3600) {
  try {
    const startTime = new Date();
    
    // ========================================
    // NIVEL 1: CacheService (Temporal - M√°s r√°pido)
    // ========================================
    const userCache = CacheService.getUserCache();
    let cached = userCache.get(key);
    
    if (cached) {
      logCacheHit('L1-CacheService', key, startTime);
      return JSON.parse(cached);
    }
    
    // ========================================
    // NIVEL 2: PropertiesService (Persistente - Peque√±o)
    // ========================================
    const userProps = PropertiesService.getUserProperties();
    cached = userProps.getProperty(key);
    
    if (cached) {
      // Promover a L1 para pr√≥ximas lecturas
      userCache.put(key, cached, Math.min(ttlSeconds, 21600)); // Max 6 horas
      logCacheHit('L2-Properties', key, startTime);
      return JSON.parse(cached);
    }
    
    // ========================================
    // NIVEL 3: Hoja Cache_Data (Hist√≥rico - Grande)
    // ========================================
    const cacheSheetData = getFromCacheSheet(key);
    
    if (cacheSheetData) {
      const json = JSON.stringify(cacheSheetData);
      
      // Promover a L1 y L2
      if (json.length < 9000) { // L√≠mite de PropertiesService
        userProps.setProperty(key, json);
      }
      userCache.put(key, json, Math.min(ttlSeconds, 21600));
      
      logCacheHit('L3-Sheet', key, startTime);
      return cacheSheetData;
    }
    
    // ========================================
    // CACHE MISS: Fetch + Store en todos los niveles
    // ========================================
    Logger.log(`‚ö†Ô∏è CACHE MISS: ${key} - Ejecutando fetchFunction...`);
    
    const data = fetchFunction();
    const json = JSON.stringify(data);
    const dataSize = json.length;
    
    // Guardar en L1 (siempre)
    if (dataSize < 100000) { // L√≠mite de CacheService
      userCache.put(key, json, Math.min(ttlSeconds, 21600));
      Logger.log(`‚úÖ Guardado en L1 (CacheService): ${key} - ${(dataSize / 1024).toFixed(2)} KB`);
    }
    
    // Guardar en L2 (si es peque√±o)
    if (dataSize < 9000) {
      userProps.setProperty(key, json);
      Logger.log(`‚úÖ Guardado en L2 (Properties): ${key}`);
    }
    
    // Guardar en L3 (siempre, si est√° habilitado)
    saveToCacheSheet(key, data, ttlSeconds);
    
    const duration = (new Date() - startTime) / 1000;
    Logger.log(`‚è±Ô∏è Total fetch time: ${duration.toFixed(3)}s para ${key}`);
    
    return data;
    
  } catch (error) {
    Logger.log(`‚ùå Error en getCached(${key}): ${error.message}`);
    // Si falla cache, ejecutar funci√≥n directamente
    return fetchFunction();
  }
}

/**
 * Invalida cache por clave exacta o patr√≥n
 * @param {string} pattern - Clave exacta o patr√≥n (ej: "hc_*")
 */
function invalidateCache(pattern) {
  try {
    Logger.log(`üóëÔ∏è Invalidando cache: ${pattern}`);
    
    const userCache = CacheService.getUserCache();
    const userProps = PropertiesService.getUserProperties();
    
    if (pattern.includes('*')) {
      // Invalidar por patr√≥n (solo Props y Sheet)
      const prefix = pattern.replace('*', '');
      const allProps = userProps.getProperties();
      
      let removed = 0;
      for (const key in allProps) {
        if (key.startsWith(prefix)) {
          userProps.deleteProperty(key);
          userCache.remove(key);
          removed++;
        }
      }
      
      Logger.log(`‚úÖ Invalidados ${removed} items con patr√≥n: ${pattern}`);
      
    } else {
      // Invalidar clave exacta
      userCache.remove(pattern);
      userProps.deleteProperty(pattern);
      invalidateFromCacheSheet(pattern);
      
      Logger.log(`‚úÖ Invalidado: ${pattern}`);
    }
    
    return { success: true, pattern: pattern };
    
  } catch (error) {
    Logger.log(`‚ùå Error en invalidateCache: ${error.message}`);
    return { success: false, error: error.message };
  }
}

/**
 * Pre-calienta cache con datos cr√≠ticos
 * Se recomienda ejecutar v√≠a trigger cada ma√±ana
 */
function warmUpCache() {
  try {
    Logger.log('üî• ========== WARM UP CACHE ==========');
    const startTime = new Date();
    
    // Datos que TODOS los usuarios necesitan
    const criticalData = [
      { key: 'all_lobs', fn: () => obtenerTodasLasLobs(), ttl: 21600 },           // 6h
      { key: 'cdm_meses', fn: () => obtenerMesesCDMDisponibles(), ttl: 86400 },    // 24h
      { key: 'hc_agentes', fn: () => obtenerAgentesPermitidos(), ttl: 3600 }       // 1h
    ];
    
    let successCount = 0;
    
    criticalData.forEach(item => {
      try {
        getCached(item.key, item.fn, item.ttl);
        successCount++;
        Logger.log(`‚úÖ Pre-cargado: ${item.key}`);
      } catch (error) {
        Logger.log(`‚ö†Ô∏è Error pre-cargando ${item.key}: ${error.message}`);
      }
    });
    
    const duration = (new Date() - startTime) / 1000;
    Logger.log(`üî• Warm-up completado: ${successCount}/${criticalData.length} en ${duration.toFixed(2)}s`);
    
    return { success: true, loaded: successCount, total: criticalData.length };
    
  } catch (error) {
    Logger.log(`‚ùå Error en warmUpCache: ${error.message}`);
    return { success: false, error: error.message };
  }
}

/**
 * Lee datos desde la hoja Cache_Data (Nivel 3)
 */
function getFromCacheSheet(key) {
  try {
    const ss = SpreadsheetApp.openById('1PtYuAb5C2kIoX8sE7dOvt1nVS-aLamZLOJQUSbTBBCw');
    let sheet = ss.getSheetByName('Cache_Data');
    
    if (!sheet) {
      return null;
    }
    
    const data = sheet.getDataRange().getValues();
    
    // Headers: Timestamp | Cache Key | Data (JSON) | TTL | Expires At
    for (let i = 1; i < data.length; i++) {
      const cacheKey = data[i][1];
      
      if (cacheKey === key) {
        const expiresAt = new Date(data[i][4]);
        const now = new Date();
        
        if (expiresAt > now) {
          // Cache v√°lido
          try {
            return JSON.parse(data[i][2]);
          } catch (e) {
            Logger.log(`‚ö†Ô∏è Error parseando JSON de cache: ${key}`);
            return null;
          }
        } else {
          // Cache expirado - eliminar fila
          sheet.deleteRow(i + 1);
          Logger.log(`üóëÔ∏è Cache expirado eliminado: ${key}`);
          return null;
        }
      }
    }
    
    return null;
    
  } catch (error) {
    Logger.log(`‚ö†Ô∏è Error leyendo Cache_Data: ${error.message}`);
    return null;
  }
}

/**
 * Guarda datos en la hoja Cache_Data (Nivel 3)
 */
function saveToCacheSheet(key, data, ttlSeconds) {
  try {
    const ss = SpreadsheetApp.openById('1PtYuAb5C2kIoX8sE7dOvt1nVS-aLamZLOJQUSbTBBCw');
    let sheet = ss.getSheetByName('Cache_Data');
    
    // Crear hoja si no existe
    if (!sheet) {
      sheet = ss.insertSheet('Cache_Data');
      sheet.appendRow(['Timestamp', 'Cache Key', 'Data (JSON)', 'TTL (seconds)', 'Expires At']);
      
      const headerRange = sheet.getRange(1, 1, 1, 5);
      headerRange.setBackground('#8e44ad');
      headerRange.setFontColor('#FFFFFF');
      headerRange.setFontWeight('bold');
      
      Logger.log('‚úÖ Hoja Cache_Data creada');
    }
    
    const now = new Date();
    const expiresAt = new Date(now.getTime() + (ttlSeconds * 1000));
    const json = JSON.stringify(data);
    
    // Verificar si ya existe
    const existingData = sheet.getDataRange().getValues();
    let updated = false;
    
    for (let i = 1; i < existingData.length; i++) {
      if (existingData[i][1] === key) {
        // Actualizar fila existente
        sheet.getRange(i + 1, 1, 1, 5).setValues([[now, key, json, ttlSeconds, expiresAt]]);
        updated = true;
        Logger.log(`üîÑ Cache actualizado en hoja: ${key}`);
        break;
      }
    }
    
    // Si no existe, agregar nueva fila
    if (!updated) {
      sheet.appendRow([now, key, json, ttlSeconds, expiresAt]);
      Logger.log(`‚úÖ Cache guardado en hoja: ${key} - ${(json.length / 1024).toFixed(2)} KB`);
    }
    
    // Limpiar cache expirado (solo si hay m√°s de 100 filas)
    if (sheet.getLastRow() > 100) {
      cleanupExpiredCache();
    }
    
  } catch (error) {
    Logger.log(`‚ö†Ô∏è Error guardando en Cache_Data: ${error.message}`);
    // No es cr√≠tico si falla, L1 y L2 ya funcionan
  }
}

/**
 * Elimina entrada de Cache_Data
 */
function invalidateFromCacheSheet(key) {
  try {
    const ss = SpreadsheetApp.openById('1PtYuAb5C2kIoX8sE7dOvt1nVS-aLamZLOJQUSbTBBCw');
    const sheet = ss.getSheetByName('Cache_Data');
    
    if (!sheet) return;
    
    const data = sheet.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][1] === key) {
        sheet.deleteRow(i + 1);
        Logger.log(`üóëÔ∏è Eliminado de Cache_Data: ${key}`);
        break;
      }
    }
    
  } catch (error) {
    Logger.log(`‚ö†Ô∏è Error invalidando Cache_Data: ${error.message}`);
  }
}

/**
 * Limpia cache expirado de la hoja
 */
function cleanupExpiredCache() {
  try {
    const ss = SpreadsheetApp.openById('1PtYuAb5C2kIoX8sE7dOvt1nVS-aLamZLOJQUSbTBBCw');
    const sheet = ss.getSheetByName('Cache_Data');
    
    if (!sheet) return;
    
    const data = sheet.getDataRange().getValues();
    const now = new Date();
    let removed = 0;
    
    // Recorrer de abajo hacia arriba para evitar problemas con √≠ndices
    for (let i = data.length - 1; i >= 1; i--) {
      const expiresAt = new Date(data[i][4]);
      
      if (expiresAt < now) {
        sheet.deleteRow(i + 1);
        removed++;
      }
    }
    
    if (removed > 0) {
      Logger.log(`üóëÔ∏è Limpiados ${removed} registros expirados de Cache_Data`);
    }
    
  } catch (error) {
    Logger.log(`‚ö†Ô∏è Error limpiando cache: ${error.message}`);
  }
}

/**
 * Logger de cache hits para debugging
 */
function logCacheHit(level, key, startTime) {
  const duration = (new Date() - startTime) / 1000;
  Logger.log(`‚úÖ CACHE HIT [${level}]: ${key} - ${(duration * 1000).toFixed(2)}ms`);
}

/**
 * Obtiene estad√≠sticas de uso de cache
 */
function getCacheStats() {
  try {
    const ss = SpreadsheetApp.openById('1PtYuAb5C2kIoX8sE7dOvt1nVS-aLamZLOJQUSbTBBCw');
    const sheet = ss.getSheetByName('Cache_Data');
    
    if (!sheet) {
      return { total: 0, expired: 0, active: 0 };
    }
    
    const data = sheet.getDataRange().getValues();
    const now = new Date();
    let expired = 0;
    let active = 0;
    
    for (let i = 1; i < data.length; i++) {
      const expiresAt = new Date(data[i][4]);
      if (expiresAt < now) {
        expired++;
      } else {
        active++;
      }
    }
    
    return {
      total: data.length - 1,
      expired: expired,
      active: active
    };
    
  } catch (error) {
    Logger.log(`‚ö†Ô∏è Error obteniendo stats: ${error.message}`);
    return { total: 0, expired: 0, active: 0 };
  }
}

/**
 * Trigger autom√°tico para warm-up diario
 * Configurar en: Edit > Current project's triggers
 * Ejecutar: warmUpCacheTrigger() cada d√≠a a las 6:00 AM
 */
function warmUpCacheTrigger() {
  Logger.log('üåÖ Ejecutando warm-up autom√°tico...');
  warmUpCache();
  
  // Limpiar cache expirado
  cleanupExpiredCache();
}

/**
 * Lee m√∫ltiples hojas en una sola ejecuci√≥n (Batch Read)
 * @param {Array<{id: string, sheet: string}>} sheetsConfig - Lista de hojas a leer
 * @returns {Array<Array<Array<string>>>} Lista de datos de cada hoja
 */
function batchReadSheets(sheetsConfig) {
  try {
    Logger.log(`üì¶ Batch Read: Leyendo ${sheetsConfig.length} hojas...`);
    const startTime = new Date();
    
    const results = sheetsConfig.map(config => {
      const ss = SpreadsheetApp.openById(config.id);
      const sheet = ss.getSheetByName(config.sheet);
      if (!sheet) return [];
      return sheet.getDataRange().getValues();
    });
    
    const duration = (new Date() - startTime) / 1000;
    Logger.log(`‚úÖ Batch Read completado en ${duration.toFixed(2)}s`);
    
    return results;
    
  } catch (error) {
    Logger.log(`‚ùå Error en batchReadSheets: ${error.message}`);
    return [];
  }
}

Logger.log('‚úÖ Cache Manager cargado correctamente');
